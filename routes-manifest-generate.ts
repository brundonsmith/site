import { path } from "./deps.ts";
import { allResources, projectPath } from "./utils.ts";

// HACK: This is a workaround for the fact that Deno Deploy doesn't allow
// dynamic imports. Instead, we dynamically generate our own manifest which
// statically imports all the route modules. If dynamic imports are ever
// allowed, this can be removed.

const routeModules = await Promise.all(allResources
    .map(file => file.path)
    .filter(file => path.extname(file) === '.ts')
    .map(async file => {
        console.log(file)
        const module = await import(file)

        return {
            module: './' + path.relative(projectPath, file),
            hasParams: module.params != null
        }
    }))

const moduleIdentifier = (module: string) =>
    '_' + module.replaceAll(/[/.\[\]]/g, '_')

const manifest = `
// THIS FILE IS AUTO-GENERATED BY \`routes-manifest-generate.ts\`!

${routeModules.map(({ module, hasParams }) =>
    `import ${moduleIdentifier(module)}${hasParams ? `, { params as ${moduleIdentifier(module)}_params }` : ''} from '${module}';`).join('\n')}

type Route = { default: (param?: string) => (string | Promise<string>), params?: string[] }

const routes: {[key: string]: Route} = {
${routeModules.map(({ module, hasParams }) =>
        `    ['${module}']: { default: ${moduleIdentifier(module)}${hasParams ? `, params: ${moduleIdentifier(module)}_params` : ''} }`).join(',\n')}
}

export default (module: string) => routes[module]
`

Deno.writeTextFileSync(path.resolve(projectPath, 'routes-manifest.ts'), manifest)